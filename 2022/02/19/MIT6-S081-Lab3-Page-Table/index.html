<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="wzmw-zr">
    
    <title>
        
            MIT6.S081 Lab3 Page Table |
        
        无字铭文のBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                无字铭文のBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">MIT6.S081 Lab3 Page Table</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">wzmw-zr</span>
                        
                            <span class="author-label">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-02-19 19:02:33</span>
        <span class="mobile">2022-02-19 19:02</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Lab3：-Page-Table"><a href="#Lab3：-Page-Table" class="headerlink" title="Lab3： Page Table"></a>Lab3： Page Table</h1><p>Lab3中，我收获最大的是Task2和Task3，<strong>理解了页表如何管理虚拟地址空间（虚拟地址到物理地址的映射）</strong>，<strong>通过将xv6原本的进程共享全局内核页表变成进程各自有进程内核页表，进程内核页表对应的地址空间低地址放进程用户空间，即进程内核页表同步进程用户页表，==加深了对进程用户虚拟地址空间、进程内核虚拟地址空间的理解==<strong>，此外，内核维护了空闲物理内存页面的链表，获取/释放物理页面，与关联的虚拟地址在页表中添加/解除映射，通过这一过程，</strong>进一步理解了进程地址空间独立的概念以及操作系统要求的隔离性</strong>。</p>
<blockquote>
<p>经过这次实验，我能够大致想到malloc等申请内存的操作调用sbrk时，物理内存的获取与用户页表、进程内核页表的变动。</p>
</blockquote>
<h2 id="Task1：-Print-a-page-table"><a href="#Task1：-Print-a-page-table" class="headerlink" title="Task1： Print a page table"></a>Task1： Print a page table</h2><p>打印page table，很容易，遍历table page，递归处理，遇到可见(PTE_V标志位为1)的，直到最后一层，答应完都需要递归处理下一层。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task1</span></span><br><span class="line"><span class="comment"> * Print given level page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pgtbl</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// prefix</span></span><br><span class="line">  <span class="keyword">char</span> prefix[level * <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    prefix[i * <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    prefix[i * <span class="number">3</span> + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    prefix[i * <span class="number">3</span> + <span class="number">2</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prefix[level * <span class="number">3</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGSIZE / <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="comment">// page table entry is visible.</span></span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, prefix, i, pte, <span class="built_in">PTE2PA</span>(pte));</span><br><span class="line">      <span class="comment">// reach the board of recursive print page table.</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// recursive print page table.</span></span><br><span class="line">      <span class="built_in">print_pgtbl</span>((<span class="keyword">pagetable_t</span>) <span class="built_in">PTE2PA</span>(pte), level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task1</span></span><br><span class="line"><span class="comment"> * Print page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span> ,pagetable);</span><br><span class="line">  <span class="comment">// recursive print page table.</span></span><br><span class="line">  <span class="built_in">print_pgtbl</span>(pagetable, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Task2：A-Kernel-page-table-per-process"><a href="#Task2：A-Kernel-page-table-per-process" class="headerlink" title="Task2：A Kernel page table per process"></a>Task2：A Kernel page table per process</h2><blockquote>
<p>进程处于内核态：进程当前运行在内核空间，运行特权指令，使用内核页表，内核栈。</p>
<p>进程处于用户态：进程当前运行在用户空间，运行用户指令，使用用户页表，用户栈。</p>
</blockquote>
<p>xv6的实现：进程有一个用户空间页表，所有进程共享一个内核页表，内核页表不含有用户空间页面的映射，因此当进程运行于内核态时，不能通过用户空间虚拟地址直接访问内存，而是要根据进程用户页表将虚拟地址转成物理地址（这一步通过软件实现的walk指令实现）。</p>
<p>全局内核页表对应的虚拟地址空间：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wzmw-zr/blog-images/kernel-virtual-address.png"></p>
<p>因为所有进程共享全局内核页表，所以内核栈是在<code>procinit()</code>中预先分配好的，并且内核页表虚拟空间中，[0, CLINT)没有使用，中间一段是直接映射，从KERNBASE往上才是与内核有关的指令、数据等。</p>
<p>进程的用户页表对应的虚拟地址空间：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wzmw-zr/blog-images/process-user-virtual-address-space.png"></p>
<p><strong>这就启发了Linux等系统为每个进程维护一个内核页表。==因为用户页表的映射对应的虚拟空间从地址0开始，可以用进程内核页表虚拟地址空间[0, PILC）额外存储用户页表的映射（一开始我还以为是CLINT，在Task3中发现是PILC）==。这样系统调用中传递的用户空间的指针参数，在进程内核页表中可以找到对应的物理页面，CPU的satp寄存器加载了进程内核页表，开启paging后可以使用MMU加速物理地址查找，不需要使用walk这种软件指令根据用户页表生成虚拟地址的物理地址</strong>。</p>
<p>本实验的Task2和Task3要求完成近似Linux的实现：进程有用户空间页表，也有进程的内核页表，该内核页表包含用户空间页表中的映射。</p>
<p>思路：</p>
<ol>
<li>修改<code>struct proc</code>，增加一项进程内核页表<code>kpagetable</code>。</li>
<li><code>proc.c</code> 的<code>allocproc()</code>创建进程内核页表，实验的Hint说修改<code>kvminit()</code>，虽然判断<code>kernel_pagetable</code>是否为空指针即可以判断当前是否是第一个进程，创建后返回页表，这样要修改函数返回值，个人觉得单独写一个函数更好。</li>
<li>xv6因为进程共享全局内核页表，所以在<code>procinit()</code>中预先设定好各进程的内核栈。但是现在进程有各自的内核页表，所以进程内核栈不需要在<code>procinit()</code>中预先设定，而且由于各个进程地址空间独立，所以各进程现在的内核栈可以是相同的虚拟地址，我用的是<code>KSTACK((int) 0)</code>（考虑到有trapframe和trampoline），获得内核栈的物理地址后，在进程内核页表中增加映射。</li>
<li>xv6之前进程共享全局内核页表，但是现在进程有自己的内核页表，所以调度切换进程需要使用进程的内核页表，修改<code>scheduler()</code>加载进程的kernel page table到CPU的satp寄存器，记得在调用w_satp()后调用sfence_vma()。没有进程运行时使用全局kernel page table。</li>
<li>在销毁进程时也要释放内核栈，解除内核栈等地址在进程内核页表中的映射，删除进程内核页表。</li>
<li>实验Hint没有提到的，<code>kvmpa()</code>中需要将<code>kernel_pagetable</code>改成当前进程使用的内核页表。</li>
</ol>
<p>一个我DEBUG了很久的地方：</p>
<p>函数<code>kvmpa()</code>中调用<code>myproc()</code>获得的不一定是调用函数<code>kvmpa()</code>的进程，我在释放进程内核栈时图方便使用<code>kvmpa()</code>，发现释放内核栈总是报错，后来打LOG发现<code>kvmpa()</code>调用<code>myproc()</code>和调用<code>kvmpa()</code>的进程不是同一个，于是老老实实手动获得内核栈物理地址，解除进程内核页表中内核栈虚拟地址和物理地址的映射，释放内核栈物理地址。</p>
<p>几处关键代码：</p>
<p><code>vm.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task2</span></span><br><span class="line"><span class="comment"> * create a direct-map kernel page table for process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">pagetable_t</span> <span class="title">kvmcreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="comment">// LOG(&quot;page table = %p&quot;, pagetable);</span></span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// direct map </span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  mappages(pagetable, UART0, PGSIZE, UART0, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  mappages(pagetable, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  mappages(pagetable, CLINT, <span class="number">0x10000</span>, CLINT, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  mappages(pagetable, PLIC, <span class="number">0x400000</span>, PLIC, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  mappages(pagetable, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  mappages(pagetable, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// translate a kernel virtual address to</span></span><br><span class="line"><span class="comment">// a physical address. only needed for</span></span><br><span class="line"><span class="comment">// addresses on the stack.</span></span><br><span class="line"><span class="comment">// assumes va is page aligned.</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kvmpa</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// current running process might not be the calling one.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// LOG(&quot;pid = %d&quot;, p-&gt;pid);</span></span><br><span class="line">  pte = walk(p-&gt;kpagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// pte = walk(kernel_pagetable, va, 0);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="comment">//LOG(&quot;process id = %d, process kernel page table = %p, virtual address = %p, page table entry content = %p, physical address = %p, offset = %p&quot;, p-&gt;pid, p-&gt;kpagetable, va, *pte, pa, off);</span></span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task 2</span></span><br><span class="line"><span class="comment"> * Erase process kernel page table of given level.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvmfree_</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LOG(&quot;pagetable = %p, level = %d&quot;, pagetable, level);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">3</span>) </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      kvmfree_((<span class="keyword">pagetable_t</span>) child, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *) pagetable);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task 2</span></span><br><span class="line"><span class="comment"> * Erase process kernel page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvmfree</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LOG(&quot;pagetable = %p&quot;, pagetable);</span></span><br><span class="line">  <span class="keyword">return</span> kvmfree_(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc*</span></span><br><span class="line"><span class="function"><span class="title">allocproc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lab3 task2: allocate process&#x27;s kernel page table.</span></span><br><span class="line">  p-&gt;kpagetable = kvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lab3 task2: </span></span><br><span class="line">  <span class="comment">// allocate process&#x27;s kernel stack, and add to process&#x27;s kernel page table.</span></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>) </span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) <span class="number">0</span>); <span class="comment">// same virtual address for each process&#x27;s kernel stack.</span></span><br><span class="line">  <span class="comment">// LOG(&quot;pid = %d, kernel page table = %p, kstack virtual address = %p, physical address = %p&quot;, p-&gt;pid, p-&gt;kpagetable, va, (uint64) pa);</span></span><br><span class="line">  mappages(p-&gt;kpagetable, va, PGSIZE, (uint64) pa, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Lab3 Task 2</span></span><br><span class="line">  <span class="comment">// remove leaf pte mapping from process kernel page table, and</span></span><br><span class="line">  <span class="comment">// free process kernel stack page.</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kstack) &#123;</span><br><span class="line">    <span class="comment">// uint64 pa = walkaddr(p-&gt;kpagetable, p-&gt;kstack);</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte = walk(p-&gt;kpagetable, p-&gt;kstack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) </span><br><span class="line">      panic(<span class="string">&quot;freeproc: walk cannot get kstack pte address&quot;</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="comment">// LOG(&quot;pid = %d, kstack vritual address = %p, physical address = %p&quot;, p-&gt;pid, p-&gt;kstack, pa);</span></span><br><span class="line">    kfree((<span class="keyword">void</span> *) pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  <span class="comment">// LOG(&quot;free process user page table&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lab3 Task2</span></span><br><span class="line">  <span class="comment">// free process&#x27;s individual kernel page table.</span></span><br><span class="line">  <span class="comment">// all PTE in process&#x27;s kernel page table should be already unmapped.</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable) </span><br><span class="line">    kvmfree(p-&gt;kpagetable);</span><br><span class="line">  <span class="comment">// LOG(&quot;free process kernel page table&quot;);</span></span><br><span class="line"></span><br><span class="line">  p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kpagetable)); <span class="comment">// load process kernel pagetable to register satp before schedule.</span></span><br><span class="line">        sfence_vma(); <span class="comment">// enable paging</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back, and</span></span><br><span class="line">        <span class="comment">// set register satp global kernel page table.</span></span><br><span class="line">        kvminithart();</span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="comment">// kvminithart();</span></span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Task3：Simplify-copyin-copyinstr"><a href="#Task3：Simplify-copyin-copyinstr" class="headerlink" title="Task3：Simplify copyin / copyinstr"></a>Task3：Simplify copyin / copyinstr</h2><p>Task2为进程增加了内核页表，补充了内核页表的创建、销毁操作，进程内核栈的获得与销毁、在内核页表中添加、删除映射等。</p>
<p>Task3的任务是将进程用户页表的映射同步到进程内核页表，需要同步的地方：<code>fork，growproc，exec</code>等涉及进程用户空间变化的地方，注意<code>userinit()</code>中也需要将进程用户页表中的映射同步到进程内核页表。</p>
<p>这个方案依赖于用户虚拟地址空间的范围和内核虚拟地址空间的范围不重叠，这样内核使用自己的指令和数据。Xv6使用从0开始的虚拟地址作为用户地址空间，幸运的是内核地址空间在更高地址开始。但是这种方案限制了进程用户空间小于内核最小虚拟地址。在内核boot后，该地址是0xC000000，PLIC寄存器的地址。需要防止用户进程增长超过PLIC，只需要在<code>exec()</code>中进行该项防范。</p>
<p>现在，xv6进程处于内核态时，可以从进程内核也表中找到copyin函数读取用户指针指向的物理内存，这可以用MMU加速，可以不使用walk软件指令找到用户指针指向的物理内存。用copyin_new替换copyin的主体，copyinstr_new替换copyinstr的主体即可。</p>
<p><code>vm.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3 Task3</span></span><br><span class="line"><span class="comment"> * Copy Content of user page table to process&#x27;s kernel page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvmcopypagetable</span><span class="params">(<span class="keyword">pagetable_t</span> upgtbl, <span class="keyword">pagetable_t</span> kpgtbl, uint64 start, uint64 end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LOG(&quot;process user page table = %p, process kernel page table = %p, start = %p, end = %p&quot;, upgtbl, kpgtbl, start, end);</span></span><br><span class="line">  start = PGROUNDUP(start);</span><br><span class="line">  <span class="keyword">for</span> (uint64 va = start; va &lt; end; va += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *upte = walk(upgtbl, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">pte_t</span> *kpte = walk(kpgtbl, va, <span class="number">1</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*upte);</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_FLAGS(*upte) &amp; ~PTE_U;</span><br><span class="line">    *kpte = PA2PTE(pa) | flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Lab3 Task3</span></span><br><span class="line"><span class="comment"> * unmap range of virtual address in process kernel page table.</span></span><br><span class="line"><span class="comment"> * Hint: `@param start` should smaller than `@param end`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvmunmap</span><span class="params">(<span class="keyword">pagetable_t</span> kpgtbl, uint64 start, uint64 end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LOG(&quot;process kernel page table = %p, start = %p, end = %p&quot;, kpgtbl, start, end);</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt;= end) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  start = PGROUNDUP(start);</span><br><span class="line">  end = PGROUNDUP(end);</span><br><span class="line">  <span class="keyword">if</span> (start == end) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (uint64 va = end; va &lt; start; va += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *kpte = walk(kpgtbl, va, <span class="number">0</span>);</span><br><span class="line">    *kpte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyin</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyinstr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">userinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LOG(&quot;pid = %d, user page table = %p, kernel page table = %p, user space = %d&quot;, p-&gt;pid, p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz);</span></span><br><span class="line">  <span class="comment">// Lab3 Task3</span></span><br><span class="line">  <span class="comment">// Copy user page table mapping to process kernel page table.</span></span><br><span class="line">  kvmcopypagetable(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// avoid process from growing larger than PLIC.</span></span><br><span class="line">    <span class="keyword">if</span> (sz + n &gt;= PLIC) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64 newsz;</span><br><span class="line">    <span class="keyword">if</span>((newsz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lab3 Task3</span></span><br><span class="line">    <span class="comment">// add new user space mapping to kernel page table.</span></span><br><span class="line">    <span class="keyword">if</span> (kvmcopypagetable(p-&gt;pagetable, p-&gt;kpagetable, sz, sz + n) &lt; <span class="number">0</span>) </span><br><span class="line">      panic(<span class="string">&quot;growproc: kvmcopypagetable() failed&quot;</span>);</span><br><span class="line">    sz = newsz;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// remove user space mapping in kernel page table.</span></span><br><span class="line">    <span class="comment">// if (kvm_remove_mapping(p-&gt;kpagetable, sz, sz + n) == -1) </span></span><br><span class="line">      <span class="comment">// panic(&quot;growproc: kvm_remove_mapping&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (kvmunmap(p-&gt;kpagetable, sz, sz + n) &lt; <span class="number">0</span>) </span><br><span class="line">      panic(<span class="string">&quot;growproc: kvmunmap() failed&quot;</span>);</span><br><span class="line">    <span class="comment">// Lab3 Task3</span></span><br><span class="line">    <span class="comment">// remove range of user space mapping in kernel page table.</span></span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lab3 Task3</span></span><br><span class="line">  <span class="comment">// Copy user page table to kernel page table.</span></span><br><span class="line">  <span class="keyword">if</span> (kvmcopypagetable(np-&gt;pagetable, np-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Copy user momory</span></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exec.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *s, *last;</span><br><span class="line">  <span class="keyword">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// avoid user process growing larger than PLIC.</span></span><br><span class="line">    <span class="keyword">if</span> (sz1 &gt;= PLIC)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// avoid user process growing larger than PLIC.</span></span><br><span class="line">  <span class="keyword">if</span> (sz1 &gt;= PLIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove original kernel page table&#x27;s user space map.</span></span><br><span class="line">  kvmunmap(p-&gt;kpagetable, oldsz, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// copy user page table to kernel page table.</span></span><br><span class="line">  kvmcopypagetable(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) </span><br><span class="line">    vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        

        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/02/19/MIT6-S081-Lab2-System-Calls/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MIT6.S081 Lab2 System Calls</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">wzmw-zr</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
</div>



</body>
</html>
