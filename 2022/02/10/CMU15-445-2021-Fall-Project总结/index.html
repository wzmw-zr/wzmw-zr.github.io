<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="wzmw-zr">
    
    <title>
        
            CMU15-445(2021 Fall) Project总结 |
        
        无字铭文のBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                无字铭文のBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CMU15-445(2021 Fall) Project总结</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">wzmw-zr</span>
                        
                            <span class="author-label">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-02-10 19:13:08</span>
        <span class="mobile">2022-02-10 19:13</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="CMU15-445-Project-总结"><a href="#CMU15-445-Project-总结" class="headerlink" title="CMU15-445 Project 总结"></a>CMU15-445 Project 总结</h1><p>花了大概2个月的时间，陆陆续续学了CMU 15-445的课程并完成了2021 Fall的4个Project，个人觉得收获很大，提升了对磁盘数据库的工作原理与流程的理解。（PS：虽然做的是2021 Fall的Project，但是视频看的是2019年Andy讲的课）</p>
<blockquote>
<p>个人觉得CMU15-445给我带来的收获：</p>
<ol>
<li>Project 1 Buffer Pool Manager，数据库向Buffer Pool Manager请求磁盘上的Page，Buffer Pool Manager会将对应的Page读入内存，这实际上就是实现内存池，需要支持多线程。</li>
<li>理解了索引（Index）的作用（加快查找），磁盘数据库中如何建立、存储表的索引，同样需要支持多线程。(<strong>Project 2 Extendible Hash Index</strong>)</li>
<li>理解了使用火山模型（Volcano Model）的SQL语句的执行过程（Query Processing），SQL语句转化成算子的表达式树（这个倒不是Project的重点），典型算子的实现（Sequential Scan，INSERT，DELETE，UPDATE，JOIN，DISTINCT等等）（<strong>Project 3 Query Execution</strong>）</li>
<li>理解了事务（Transaction）的ACID特性（尤其是隔离性），共享锁、排他锁的实现（通过锁管理器实现获取共享锁、排他锁，升级锁，解锁操作）、死锁的预防，事务的隔离级别与事务的并发控制（Concurrency Control，解决的是Isolation问题）。（<strong>Project 4 Concurrency Control</strong>）</li>
<li>这几个Project做下来，还加深了我对多线程编程的理解，理解了Manager管理器设计模式（Project 3源码部分有工厂模式的应用）。</li>
</ol>
</blockquote>
<h2 id="Project-1-Buffer-Pool-Manager"><a href="#Project-1-Buffer-Pool-Manager" class="headerlink" title="Project 1 Buffer Pool Manager"></a>Project 1 Buffer Pool Manager</h2><p>Project 1 需要实现Buffer Pool Manager，即内存池。</p>
<h3 id="LRU-Replacement-Policy"><a href="#LRU-Replacement-Policy" class="headerlink" title="LRU Replacement Policy"></a>LRU Replacement Policy</h3><p>LRU逻辑很简单，链表 + 哈希表，可以去LeetCode上找LRU的题目做一下就熟悉了。</p>
<p>这里LRU管理的是frame，存放page（tableheap，index等等）的frame，是Buffer Pool Manager管理当前frame资源的方法。</p>
<p>上层 BufferPool <code>Pin()</code> 了一个 page，然后上层找到该 page 的 frame，然后 LRU 需要移除这个 frame，不进行淘汰（因为上层在使用中）。反之，如果上层 BufferPool <code>UnPin()</code> 了一个 page，然后就要把该 page 对应的 frame 加入 LRU，表示可以被移除（通过<code>Victim()</code>方法）。</p>
<p>这里需要实现的<code>Pin()，UnPin()，Victim()，Size()</code>都需要加锁，可以选择<code>std::lock_guard&lt;std::mutex&gt;，std::unique_lock&lt;std::mutex&gt;，std::scope_lock&lt;std::mutex&gt;</code>，这3者都能够在析构时自动解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="keyword">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(replacer_lock_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (lru_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *frame_id = lru_list_.<span class="built_in">back</span>();</span><br><span class="line">  lru_list_.<span class="built_in">pop_back</span>();</span><br><span class="line">  lru_map_.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="keyword">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(replacer_lock_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (lru_map_.<span class="built_in">count</span>(frame_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lru_list_.<span class="built_in">erase</span>(lru_map_[frame_id]);</span><br><span class="line">  lru_map_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="keyword">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(replacer_lock_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (lru_map_.<span class="built_in">count</span>(frame_id) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lru_list_.<span class="built_in">push_front</span>(frame_id);</span><br><span class="line">  lru_map_[frame_id] = lru_list_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(replacer_lock_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(lru_map_.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Buffer-Pool-Manager-Instance"><a href="#Buffer-Pool-Manager-Instance" class="headerlink" title="Buffer Pool Manager Instance"></a>Buffer Pool Manager Instance</h3><p>这部分其实也很简单。。。直接贴代码，不过还是需要注意并发和将page从磁盘读取、写回磁盘需要对Page加锁，以及在获取新Page时根据free_list判断是否需要用LRUReplacer执行Victim找替换的frame。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferPoolManagerInstance::WriteBackDisk</span><span class="params">(Page *page)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;[Invoke WriteBackDisk()]&quot; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">nullptr</span> || page-&gt;page_id_ == INVALID_PAGE_ID || !page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;rwlatch_.<span class="built_in">WLock</span>();</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page-&gt;rwlatch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferPoolManagerInstance::ReadFromDisk</span><span class="params">(Page *page)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// page is null</span></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// invalid page id</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;rwlatch_.<span class="built_in">WLock</span>();</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page-&gt;page_id_, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  page-&gt;rwlatch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// Invalid page id</span></span><br><span class="line">  <span class="keyword">if</span> (page_id == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// page id not in page table.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You can do it!</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[page_id, frame_id] : page_table_) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].<span class="built_in">GetData</span>());</span><br><span class="line">    pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="keyword">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// Find unpinned page.</span></span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id = <span class="keyword">static_cast</span>&lt;<span class="keyword">frame_id_t</span>&gt;(pool_size_) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; pool_size_; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[i].<span class="built_in">GetPinCount</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frame_id = <span class="keyword">static_cast</span>&lt;<span class="keyword">frame_id_t</span>&gt;(i);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If no unpinned page, return nullptr.</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id == <span class="keyword">static_cast</span>&lt;<span class="keyword">frame_id_t</span>&gt;(pool_size_) + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if has unpinned page, first select empty frame from free list,</span></span><br><span class="line">  <span class="comment">// if not , then from LRUReplacer.</span></span><br><span class="line">  <span class="comment">// Nothing, just to avoid clang-tidy consider nullptr is wrong.</span></span><br><span class="line">  Page *page = &amp;pages_[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = &amp;pages_[frame_id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id)) &#123;</span><br><span class="line">      page = &amp;pages_[frame_id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if original page if dirty, write back to disk.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  <span class="comment">// Clear page content</span></span><br><span class="line">  page-&gt;page_id_ = *page_id;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page_table_[*page_id] = frame_id;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// if page id in page table</span></span><br><span class="line">  <span class="comment">// increase page pin_count_</span></span><br><span class="line">  <span class="comment">// remove from replacer.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pages_[page_table_[page_id]].pin_count_++;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(page_table_[page_id]);</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[page_table_[page_id]];</span><br><span class="line">  &#125;</span><br><span class="line">  Page *page = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="comment">// find available page from free list and replacer.</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = &amp;pages_[frame_id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id)) &#123;</span><br><span class="line">      page = &amp;pages_[frame_id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if no available page, return nullptr</span></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if page is dirty, write to disk.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// remove page-&gt;page_id from page table</span></span><br><span class="line">  <span class="comment">// add new page id and frame id to page table</span></span><br><span class="line">  <span class="comment">// remove frame id from replacer.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  page_table_[page_id] = frame_id;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  <span class="comment">// set page information and read from disk</span></span><br><span class="line">  page-&gt;page_id_ = page_id;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page-&gt;page_id_, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// if page not in the page table, needn&#x27;t delete, return true.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// if page is pinned, cannot delete, return false.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetPinCount</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if page is dirty, write to disk.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// clear page</span></span><br><span class="line">  page-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">0</span>;</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="comment">// remove from LRUReplacer, and page table</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);</span><br><span class="line">  <span class="comment">// add frame id to free list</span></span><br><span class="line">  free_list_.<span class="built_in">emplace_back</span>(frame_id);</span><br><span class="line">  <span class="comment">// TODO(Me) : When should I call DeallocatePage ?</span></span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// page id not in page table, return false</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// if pin count leq than 0, return false</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// decrease pin count, if it reach 0, add to replacer.</span></span><br><span class="line">  <span class="keyword">if</span> ((--page-&gt;pin_count_) == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set page dirty when it&#x27;s dirty</span></span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;</span><br><span class="line">    page-&gt;is_dirty_ = is_dirty;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Parallel-Buffer-Pool-Manager"><a href="#Parallel-Buffer-Pool-Manager" class="headerlink" title="Parallel Buffer Pool Manager"></a>Parallel Buffer Pool Manager</h3><p>需要实现的函数的大概思路：找到对应的BufferPoolInstance，执行对应函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ParallelBufferPoolManager::GetPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get size of all BufferPoolManagerInstances</span></span><br><span class="line">  <span class="keyword">size_t</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    ans += instances_[i]-&gt;<span class="built_in">GetPoolSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BufferPoolManager *<span class="title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span></span><br><span class="line">  <span class="keyword">size_t</span> ind = page_id % num_instances_;</span><br><span class="line">  <span class="keyword">return</span> instances_[ind];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::FetchPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">auto</span> bpm = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> bpm-&gt;<span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParallelBufferPoolManager::UnpinPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Unpin page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">auto</span> bpm = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> bpm-&gt;<span class="built_in">UnpinPage</span>(page_id, is_dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParallelBufferPoolManager::FlushPgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Flush page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">auto</span> bpm = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> bpm-&gt;<span class="built_in">FlushPage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::NewPgImp</span><span class="params">(<span class="keyword">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// create new page. We will request page allocation in a round robin manner from the underlying</span></span><br><span class="line">  <span class="comment">// BufferPoolManagerInstances</span></span><br><span class="line">  <span class="comment">// 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to</span></span><br><span class="line">  <span class="comment">// starting index and return nullptr</span></span><br><span class="line">  <span class="comment">// 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function</span></span><br><span class="line">  <span class="comment">// is called</span></span><br><span class="line">  Page *page = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    page = instances_[i]-&gt;<span class="built_in">NewPage</span>(page_id);</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParallelBufferPoolManager::DeletePgImp</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Delete page_id from responsible BufferPoolManagerInstance</span></span><br><span class="line">  <span class="keyword">auto</span> bpm = <span class="built_in">GetBufferPoolManager</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> bpm-&gt;<span class="built_in">DeletePage</span>(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// flush all pages from all BufferPoolManagerInstances</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++) &#123;</span><br><span class="line">    instances_[i]-&gt;<span class="built_in">FlushAllPages</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Project-2-Extendible-Hash-Index"><a href="#Project-2-Extendible-Hash-Index" class="headerlink" title="Project 2 Extendible Hash Index"></a>Project 2 Extendible Hash Index</h2><p>2021 Fall 的Project 2要求实现Extendible Hash Table，存储Index，本次Project的Extendible Hash Index：<strong>Tuple中的字段进行hash得到key，Tuple的rid作为value</strong>（通常建立索引就是为了加快查找）。（由于<strong>这是可以写到磁盘上的哈希表，所以有些内存装不下的Hash Join可以使用Extendible Hash Table，不过后面Project 3的Hash Join用不到，内存够放数据</strong>）。</p>
<blockquote>
<p>2022年看看是不是B+ Tree Index，是的话我就将4个新Project做了，再看CMU15-645查漏补缺。</p>
</blockquote>
<p>这部分看课程视频、PPT，实验指导和官方在代码中给的注释就大概知道如何Split和Merge了（以及Merge的条件）。</p>
<p>需要注意的点：</p>
<ul>
<li>Bucket Page按照磁盘Page大小是4KB，不要为了并发自己在Bucket Page中加个mutex，这会导致实际Bucket Page超过4KB（上面实现的Buffer Pool中的frame中的data字段就是Bucket Page等Page存放数据的地方，一般用<code>reinterpret_cast</code>进行强制类型转换成Bucket Page等Page的类型再操作）。[因为虚函数表的存在，所以Page最开始8个字节是虚函数表的地址，代码注释中认为的Page结构倒是没考虑这一点]</li>
<li>及时UnPin掉不用的Page。</li>
</ul>
<h3 id="Bucket-Page"><a href="#Bucket-Page" class="headerlink" title="Bucket Page"></a>Bucket Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traverse slots, fetch all values of specified key.</span></span><br><span class="line"><span class="comment">// if specified key exits, add the value to @param `result`, and return true</span></span><br><span class="line"><span class="comment">// else return false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::GetValue</span><span class="params">(KeyType key, KeyComparator cmp, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(i) &amp;&amp; <span class="built_in">cmp</span>(<span class="built_in">KeyAt</span>(i), key) == <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;<span class="built_in">push_back</span>(<span class="built_in">ValueAt</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Insert</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check whether duplicated</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">KeyAt</span>(i), key) == <span class="number">0</span> &amp;&amp; <span class="built_in">ValueAt</span>(i) == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find first available position.</span></span><br><span class="line">  <span class="keyword">size_t</span> ind = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ind &lt; BUCKET_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsReadable</span>(ind)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ind++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No empty space.</span></span><br><span class="line">  <span class="keyword">if</span> (ind == BUCKET_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  array_[ind].first = key;</span><br><span class="line">  array_[ind].second = value;</span><br><span class="line">  <span class="built_in">SetOccupied</span>(ind);</span><br><span class="line">  <span class="built_in">SetReadable</span>(ind);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Remove</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">KeyAt</span>(i), key) == <span class="number">0</span> &amp;&amp; <span class="built_in">ValueAt</span>(i) == value) &#123;</span><br><span class="line">      <span class="built_in">RemoveAt</span>(i);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">KeyType <span class="title">HASH_TABLE_BUCKET_TYPE::KeyAt</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array_[bucket_idx].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">ValueType <span class="title">HASH_TABLE_BUCKET_TYPE::ValueAt</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array_[bucket_idx].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::RemoveAt</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> c = readable_[bucket_idx / <span class="number">8</span>];</span><br><span class="line">  c &amp;= ~(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">1</span>) &lt;&lt; (bucket_idx % <span class="number">8</span>));</span><br><span class="line">  readable_[bucket_idx / <span class="number">8</span>] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsOccupied</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> c = occupied_[bucket_idx / <span class="number">8</span>];</span><br><span class="line">  c &amp;= (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">1</span>) &lt;&lt; (bucket_idx % <span class="number">8</span>));</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::SetOccupied</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> c = occupied_[bucket_idx / <span class="number">8</span>];</span><br><span class="line">  c |= (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">1</span>) &lt;&lt; (bucket_idx % <span class="number">8</span>));</span><br><span class="line">  occupied_[bucket_idx / <span class="number">8</span>] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsReadable</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> c = readable_[bucket_idx / <span class="number">8</span>];</span><br><span class="line">  c &amp;= (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">1</span>) &lt;&lt; (bucket_idx % <span class="number">8</span>));</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::SetReadable</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> c = readable_[bucket_idx / <span class="number">8</span>];</span><br><span class="line">  c |= (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">1</span>) &lt;&lt; (bucket_idx % <span class="number">8</span>));</span><br><span class="line">  readable_[bucket_idx / <span class="number">8</span>] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_BUCKET_TYPE::NumReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::PrintBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> taken = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> free = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">      taken++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      free++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Bucket Capacity: %lu, Size: %u, Taken: %u, Free: %u&quot;</span>, BUCKET_ARRAY_SIZE, size, taken, free);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Directory-Page"><a href="#Directory-Page" class="headerlink" title="Directory Page"></a>Directory Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">page_id_t</span> <span class="title">HashTableDirectoryPage::GetPageId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> page_id_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::SetPageId</span><span class="params">(bustub::<span class="keyword">page_id_t</span> page_id)</span> </span>&#123; page_id_ = page_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">lsn_t</span> <span class="title">HashTableDirectoryPage::GetLSN</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lsn_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::SetLSN</span><span class="params">(<span class="keyword">lsn_t</span> lsn)</span> </span>&#123; lsn_ = lsn; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> local_depth = local_depths_[bucket_idx];</span><br><span class="line">  <span class="keyword">return</span> bucket_idx ^ (<span class="number">1</span> &lt;&lt; (local_depth - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetGlobalDepth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> global_depth_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetGlobalDepthMask</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increase global depth, and copy bucket page ids, local depths</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::IncrGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="built_in">Size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    bucket_page_ids_[i + size] = bucket_page_ids_[i];</span><br><span class="line">    local_depths_[i + size] = local_depths_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  global_depth_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::DecrGlobalDepth</span><span class="params">()</span> </span>&#123; global_depth_--; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">page_id_t</span> <span class="title">HashTableDirectoryPage::GetBucketPageId</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123; <span class="keyword">return</span> bucket_page_ids_[bucket_idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::SetBucketPageId</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx, <span class="keyword">page_id_t</span> bucket_page_id)</span> </span>&#123;</span><br><span class="line">  bucket_page_ids_[bucket_idx] = bucket_page_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; global_depth_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if all local depth strictly less than global depth, return true.</span></span><br><span class="line"><span class="comment">// else return false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTableDirectoryPage::CanShrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> size = <span class="built_in">Size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (local_depths_[i] &gt;= global_depth_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123; <span class="keyword">return</span> local_depths_[bucket_idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalDepthMask</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; local_depths_[bucket_idx]) - <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::SetLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx, <span class="keyword">uint8_t</span> local_depth)</span> </span>&#123;</span><br><span class="line">  local_depths_[bucket_idx] = local_depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assume only bucket is full and need split, it will increase local depth.</span></span><br><span class="line"><span class="comment">// get split bucket index, and increase both (Archived).</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::IncrLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123; ++local_depths_[bucket_idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only bucket is empty decrease local_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::DecrLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123; --local_depths_[bucket_idx]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalHighBit</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bucket_idx &gt;&gt; (<span class="number">32</span> - local_depths_[bucket_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VerifyIntegrity - Use this for debugging but **DO NOT CHANGE**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you want to make changes to this, make a new function and extend it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Verify the following invariants:</span></span><br><span class="line"><span class="comment"> * (1) All LD &lt;= GD.</span></span><br><span class="line"><span class="comment"> * (2) Each bucket has precisely 2^(GD - LD) pointers pointing to it.</span></span><br><span class="line"><span class="comment"> * (3) The LD is the same at each index with the same bucket_page_id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::VerifyIntegrity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  build maps of &#123;bucket_page_id : pointer_count&#125; and &#123;bucket_page_id : local_depth&#125;</span></span><br><span class="line">  std::unordered_map&lt;<span class="keyword">page_id_t</span>, <span class="keyword">uint32_t</span>&gt; page_id_to_count = std::unordered_map&lt;<span class="keyword">page_id_t</span>, <span class="keyword">uint32_t</span>&gt;();</span><br><span class="line">  std::unordered_map&lt;<span class="keyword">page_id_t</span>, <span class="keyword">uint32_t</span>&gt; page_id_to_ld = std::unordered_map&lt;<span class="keyword">page_id_t</span>, <span class="keyword">uint32_t</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  verify for each bucket_page_id, pointer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> curr_idx = <span class="number">0</span>; curr_idx &lt; <span class="built_in">Size</span>(); curr_idx++) &#123;</span><br><span class="line">    <span class="keyword">page_id_t</span> curr_page_id = bucket_page_ids_[curr_idx];</span><br><span class="line">    <span class="keyword">uint32_t</span> curr_ld = local_depths_[curr_idx];</span><br><span class="line">    <span class="built_in">assert</span>(curr_ld &lt;= global_depth_);</span><br><span class="line"></span><br><span class="line">    ++page_id_to_count[curr_page_id];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page_id_to_ld.<span class="built_in">count</span>(curr_page_id) &gt; <span class="number">0</span> &amp;&amp; curr_ld != page_id_to_ld[curr_page_id]) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> old_ld = page_id_to_ld[curr_page_id];</span><br><span class="line">      <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Verify Integrity: curr_local_depth: %u, old_local_depth %u, for page_id: %u&quot;</span>, curr_ld, old_ld,</span><br><span class="line">               curr_page_id);</span><br><span class="line">      <span class="built_in">PrintDirectory</span>();</span><br><span class="line">      <span class="built_in">assert</span>(curr_ld == page_id_to_ld[curr_page_id]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      page_id_to_ld[curr_page_id] = curr_ld;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = page_id_to_count.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (it != page_id_to_count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">page_id_t</span> curr_page_id = it-&gt;first;</span><br><span class="line">    <span class="keyword">uint32_t</span> curr_count = it-&gt;second;</span><br><span class="line">    <span class="keyword">uint32_t</span> curr_ld = page_id_to_ld[curr_page_id];</span><br><span class="line">    <span class="keyword">uint32_t</span> required_count = <span class="number">0x1</span> &lt;&lt; (global_depth_ - curr_ld);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curr_count != required_count) &#123;</span><br><span class="line">      <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Verify Integrity: curr_count: %u, required_count %u, for page_id: %u&quot;</span>, curr_ld, required_count,</span><br><span class="line">               curr_page_id);</span><br><span class="line">      <span class="built_in">PrintDirectory</span>();</span><br><span class="line">      <span class="built_in">assert</span>(curr_count == required_count);</span><br><span class="line">    &#125;</span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::PrintDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;======== DIRECTORY (global_depth_: %u) ========&quot;</span>, global_depth_);</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;| bucket_idx | page_id | local_depth |&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> idx = <span class="number">0</span>; idx &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="number">0x1</span> &lt;&lt; global_depth_); idx++) &#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;|      %u     |     %u     |     %u     |&quot;</span>, idx, bucket_page_ids_[idx], local_depths_[idx]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;================ END DIRECTORY ================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a>Extendible Hash Table</h3><p>这个我直接全局加锁了，其实可以加Bucket Page上更细粒度的锁，提高并发能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line">HASH_TABLE_TYPE::<span class="built_in">ExtendibleHashTable</span>(<span class="keyword">const</span> std::string &amp;name, BufferPoolManager *buffer_pool_manager,</span><br><span class="line">                                     <span class="keyword">const</span> KeyComparator &amp;comparator, HashFunction&lt;KeyType&gt; hash_fn)</span><br><span class="line">    : <span class="built_in">buffer_pool_manager_</span>(buffer_pool_manager), <span class="built_in">comparator_</span>(comparator), <span class="built_in">hash_fn_</span>(std::<span class="built_in">move</span>(hash_fn)) &#123;</span><br><span class="line">  <span class="comment">// Get new page and treat it data field as directory page.</span></span><br><span class="line">  Page *page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;directory_page_id_);</span><br><span class="line">  HashTableDirectoryPage *dir_page = <span class="keyword">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="comment">// set directory page id</span></span><br><span class="line">  dir_page-&gt;<span class="built_in">SetPageId</span>(directory_page_id_);</span><br><span class="line">  <span class="comment">// Initialize first bucket</span></span><br><span class="line">  <span class="keyword">page_id_t</span> bucket_page_id;</span><br><span class="line">  page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;bucket_page_id);</span><br><span class="line">  <span class="comment">// set first bucket in directory page. TODO(Me) : set each bucket same bucket id.</span></span><br><span class="line">  dir_page-&gt;<span class="built_in">SetBucketPageId</span>(<span class="number">0</span>, bucket_page_id);</span><br><span class="line">  <span class="comment">// Unpin first two page.</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * HELPERS</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash - simple helper to downcast MurmurHash&#x27;s 64-bit hash to 32-bit</span></span><br><span class="line"><span class="comment"> * for extendible hashing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key the key to hash</span></span><br><span class="line"><span class="comment"> * @return the downcasted 32-bit hash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::Hash</span><span class="params">(KeyType key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(hash_fn_.<span class="built_in">GetHash</span>(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Directory entry index (Bucket index).</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::KeyToDirectoryIndex</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> idx = <span class="built_in">Hash</span>(key) &amp; dir_page-&gt;<span class="built_in">GetGlobalDepthMask</span>();</span><br><span class="line">  <span class="comment">// split and merge occur in the actual first bucket_idx.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_idx = idx &amp; dir_page-&gt;<span class="built_in">GetLocalDepthMask</span>(idx);</span><br><span class="line">  <span class="keyword">return</span> bucket_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return page id of given key.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::KeyToPageId</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dir_page-&gt;<span class="built_in">GetBucketPageId</span>(<span class="built_in">KeyToDirectoryIndex</span>(key, dir_page));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice : the data field of fetched page is the content of hash table dirctory page.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">HashTableDirectoryPage *<span class="title">HASH_TABLE_TYPE::FetchDirectoryPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HashTableDirectoryPage *page =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(directory_page_id_)-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice : the data field of fetched page is the content of hash table bucket page.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">HASH_TABLE_BUCKET_TYPE *<span class="title">HASH_TABLE_TYPE::FetchBucketPage</span><span class="params">(<span class="keyword">page_id_t</span> bucket_page_id)</span> </span>&#123;</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *page =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(bucket_page_id)-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">Page *<span class="title">HASH_TABLE_TYPE::FetchPage</span><span class="params">(<span class="keyword">page_id_t</span> bucket_page_id)</span> </span>&#123;</span><br><span class="line">  Page *page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function">HASH_TABLE_BUCKET_TYPE *<span class="title">HASH_TABLE_TYPE::FetchBucket</span><span class="params">(Page *bucket_page)</span> </span>&#123;</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *bucket = <span class="keyword">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(bucket_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="keyword">return</span> bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * SEARCH</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::GetValue</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get bucket page and search, the upper page of bucket page should call RLatch()</span></span><br><span class="line">  <span class="comment">// table_latch_.RLock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  <span class="keyword">auto</span> *directory = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">auto</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">auto</span> *bucket = <span class="built_in">FetchBucket</span>(bucket_page);</span><br><span class="line">  <span class="comment">// bucket_page-&gt;RLatch();</span></span><br><span class="line">  <span class="keyword">bool</span> ans = bucket-&gt;<span class="built_in">GetValue</span>(key, comparator_, result);</span><br><span class="line">  <span class="comment">// bucket_page-&gt;RUnlatch();</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// table_latch_.RUnlock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * INSERTION</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::Insert</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// table_latch_.RLock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  <span class="keyword">auto</span> *directory = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="comment">// uint32_t bucket_idx = KeyToDirectoryIndex(key, dir_page);</span></span><br><span class="line">  <span class="keyword">auto</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">auto</span> *bucket = <span class="built_in">FetchBucket</span>(bucket_page);</span><br><span class="line">  <span class="comment">// bucket page is not full, insert, unpin, and return</span></span><br><span class="line">  <span class="comment">// bucket_page-&gt;RLatch();</span></span><br><span class="line">  <span class="keyword">bool</span> is_full = bucket-&gt;<span class="built_in">IsFull</span>();</span><br><span class="line">  <span class="comment">// bucket_page-&gt;RUnlatch();</span></span><br><span class="line">  <span class="keyword">if</span> (!is_full) &#123;</span><br><span class="line">    <span class="comment">// bucket_page-&gt;WLatch();</span></span><br><span class="line">    <span class="keyword">bool</span> res = bucket-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">    <span class="comment">// bucket_page-&gt;WUnlatch();</span></span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, res);</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, res);</span><br><span class="line">    <span class="comment">// table_latch_.RUnlock();</span></span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// This snippet may be unnessary.</span></span><br><span class="line">  <span class="comment">// bucket page is full</span></span><br><span class="line">  <span class="comment">// 1. Check whether duplicated.</span></span><br><span class="line">  std::vector&lt;ValueType&gt; results;</span><br><span class="line">  <span class="comment">// bucket_page-&gt;RLatch();</span></span><br><span class="line">  bucket-&gt;<span class="built_in">GetValue</span>(key, comparator_, &amp;results);</span><br><span class="line">  <span class="comment">// bucket_page-&gt;RUnlatch();</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;val : results) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == value) &#123;</span><br><span class="line">      buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">      buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// table_latch_.RUnlock();</span></span><br><span class="line">      table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// table_latch_.RUnlock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SplitInsert</span>(transaction, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. If exist same key-value pair, return false.</span></span><br><span class="line"><span class="comment">// 2. If local depth == global depth, increase global depth first, details in IncrGlobalDepth(),</span></span><br><span class="line"><span class="comment">// need to copy local depth and bucket page id, then increase global depth.</span></span><br><span class="line"><span class="comment">// 3. increase local depth, new split page and set its page id, then update origin page and split page&#x27;s local depth (in</span></span><br><span class="line"><span class="comment">// IncrLocalDepth()).</span></span><br><span class="line"><span class="comment">// 4. rearrange the key-value pair.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::SplitInsert</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// table_latch_.WLock();</span></span><br><span class="line">  <span class="comment">// Split and rearrange key-value pairs.</span></span><br><span class="line">  <span class="comment">// if local depth == global depth, increase both.</span></span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  <span class="keyword">auto</span> *directory = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, directory);</span><br><span class="line">  <span class="keyword">auto</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">auto</span> *bucket = <span class="built_in">FetchBucket</span>(bucket_page);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (directory-&gt;<span class="built_in">GetGlobalDepth</span>() == directory-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx)) &#123;</span><br><span class="line">    directory-&gt;<span class="built_in">IncrGlobalDepth</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate new page to split bucket page</span></span><br><span class="line">  <span class="keyword">page_id_t</span> split_bucket_page_id;</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *split_bucket =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;split_bucket_page_id)-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increase original local depth first,</span></span><br><span class="line">  <span class="comment">// then split bucket.</span></span><br><span class="line">  <span class="comment">// set split bucket page local depth same as new original bucket&#x27;s</span></span><br><span class="line">  <span class="comment">// depth.</span></span><br><span class="line">  directory-&gt;<span class="built_in">IncrLocalDepth</span>(bucket_idx);</span><br><span class="line">  <span class="keyword">uint32_t</span> split_bucket_idx = directory-&gt;<span class="built_in">GetSplitImageIndex</span>(bucket_idx);</span><br><span class="line">  directory-&gt;<span class="built_in">SetLocalDepth</span>(split_bucket_idx, directory-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx));</span><br><span class="line">  <span class="comment">// set information of positions point to same original, split buckets</span></span><br><span class="line">  <span class="keyword">uint32_t</span> offset = (<span class="number">1</span> &lt;&lt; directory-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = bucket_idx; i &lt; directory-&gt;<span class="built_in">Size</span>(); i += offset) &#123;</span><br><span class="line">    directory-&gt;<span class="built_in">SetBucketPageId</span>(i, bucket_page_id);</span><br><span class="line">    directory-&gt;<span class="built_in">SetLocalDepth</span>(i, directory-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = split_bucket_idx; i &lt; directory-&gt;<span class="built_in">Size</span>(); i += offset) &#123;</span><br><span class="line">    directory-&gt;<span class="built_in">SetBucketPageId</span>(i, split_bucket_page_id);</span><br><span class="line">    directory-&gt;<span class="built_in">SetLocalDepth</span>(i, directory-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// rearrange key-value pairs</span></span><br><span class="line">  <span class="comment">// flag illustrate whether buckets&#x27; content change.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> mask = directory-&gt;<span class="built_in">GetLocalDepthMask</span>(bucket_idx);</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bucket-&gt;<span class="built_in">IsOccupied</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!bucket-&gt;<span class="built_in">IsReadable</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    KeyType <span class="keyword">key_t</span> = bucket-&gt;<span class="built_in">KeyAt</span>(i);</span><br><span class="line">    ValueType <span class="keyword">val_t</span> = bucket-&gt;<span class="built_in">ValueAt</span>(i);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">Hash</span>(<span class="keyword">key_t</span>) &amp; mask) == bucket_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    split_bucket-&gt;<span class="built_in">Insert</span>(<span class="keyword">key_t</span>, <span class="keyword">val_t</span>, comparator_);</span><br><span class="line">    bucket-&gt;<span class="built_in">Remove</span>(<span class="keyword">key_t</span>, <span class="keyword">val_t</span>, comparator_);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, flag);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_bucket_page_id, flag);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// table_latch_.WUnlock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Insert</span>(transaction, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * REMOVE</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::Remove</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// table_latch_.RLock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  <span class="keyword">auto</span> *directory = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">auto</span> *bucket = <span class="built_in">FetchBucket</span>(bucket_page);</span><br><span class="line">  <span class="comment">// bucket_page-&gt;WLatch();</span></span><br><span class="line">  <span class="keyword">bool</span> flag = bucket-&gt;<span class="built_in">Remove</span>(key, value, comparator_);</span><br><span class="line">  <span class="comment">// bucket_page-&gt;WUnlatch();</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, flag);</span><br><span class="line">  <span class="comment">// table_latch_.RUnlock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    <span class="built_in">Merge</span>(transaction, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * MERGE</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_TYPE::Merge</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// table_latch_.WLock();</span></span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  <span class="keyword">auto</span> *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, dir_page);</span><br><span class="line">  <span class="keyword">page_id_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, dir_page);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">auto</span> *bucket = <span class="built_in">FetchBucket</span>(bucket_page);</span><br><span class="line">  <span class="comment">// bucket no longer empty</span></span><br><span class="line">  <span class="keyword">if</span> (!bucket-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Empty after remove, but local depth is 0</span></span><br><span class="line">  <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx) == <span class="number">0</span>) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bucket local depth not equal to split bucket local depth</span></span><br><span class="line">  <span class="keyword">uint32_t</span> split_bucket_idx = dir_page-&gt;<span class="built_in">GetSplitImageIndex</span>(bucket_idx);</span><br><span class="line">  <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">GetLocalDepth</span>(bucket_idx) != dir_page-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx)) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>);</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// split bucket has same depth with original bucket.</span></span><br><span class="line">  <span class="comment">// merge empty bucket.</span></span><br><span class="line">  <span class="keyword">page_id_t</span> split_bucket_page_id = dir_page-&gt;<span class="built_in">GetBucketPageId</span>(split_bucket_idx);</span><br><span class="line">  <span class="comment">// decrease split bucket page local depth.</span></span><br><span class="line">  dir_page-&gt;<span class="built_in">DecrLocalDepth</span>(split_bucket_idx);</span><br><span class="line">  <span class="keyword">auto</span> local_depth = dir_page-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx);</span><br><span class="line">  <span class="comment">// overwrite all pos with origin bucket page id, and split page id</span></span><br><span class="line">  <span class="comment">// to split bucket page id, and decrease local depth.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; dir_page-&gt;<span class="built_in">Size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">GetBucketPageId</span>(i) == bucket_page_id) &#123;</span><br><span class="line">      dir_page-&gt;<span class="built_in">SetBucketPageId</span>(i, split_bucket_page_id);</span><br><span class="line">      dir_page-&gt;<span class="built_in">SetLocalDepth</span>(i, local_depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir_page-&gt;<span class="built_in">GetBucketPageId</span>(i) == split_bucket_page_id) &#123;</span><br><span class="line">      dir_page-&gt;<span class="built_in">SetLocalDepth</span>(i, local_depth);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delete bucket page id</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>);</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">DeletePage</span>(bucket_page_id);</span><br><span class="line">  <span class="keyword">while</span> (dir_page-&gt;<span class="built_in">CanShrink</span>()) &#123;</span><br><span class="line">    dir_page-&gt;<span class="built_in">DecrGlobalDepth</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">true</span>);</span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * GETGLOBALDEPTH - DO NOT TOUCH</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::GetGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">  HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> global_depth = dir_page-&gt;<span class="built_in">GetGlobalDepth</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>, <span class="literal">nullptr</span>));</span><br><span class="line">  table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> global_depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * VERIFY INTEGRITY - DO NOT TOUCH</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_TYPE::VerifyIntegrity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">  HashTableDirectoryPage *dir_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  dir_page-&gt;<span class="built_in">VerifyIntegrity</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page_id_, <span class="literal">false</span>, <span class="literal">nullptr</span>));</span><br><span class="line">  table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * TEMPLATE DEFINITIONS - DO NOT TOUCH</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>, IntComparator&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span>GenericKey&lt;<span class="number">4</span>&gt;, RID, GenericComparator&lt;<span class="number">4</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span>GenericKey&lt;<span class="number">8</span>&gt;, RID, GenericComparator&lt;<span class="number">8</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span>GenericKey&lt;<span class="number">16</span>&gt;, RID, GenericComparator&lt;<span class="number">16</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span>GenericKey&lt;<span class="number">32</span>&gt;, RID, GenericComparator&lt;<span class="number">32</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHashTable</span>&lt;</span>GenericKey&lt;<span class="number">64</span>&gt;, RID, GenericComparator&lt;<span class="number">64</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>



<h2 id="Project-3-Query-Execution"><a href="#Project-3-Query-Execution" class="headerlink" title="Project 3 Query Execution"></a>Project 3 Query Execution</h2><p>Project 3 Query Execution需要实现基于火山模型（Volcano Model）的SQL语句中的基本操作（Scan，Insert，Delete，Update，Distinct，Join等），这个Project做完，看到一条SQL语句，可以想到一个粗略的查询执行流程（类似表达式树）。(不过这部分需要看挺多源码，有很多API不看源码是不知道的)</p>
<blockquote>
<p>Tips:如果当前Executor有子Executor，需要在Init()中调用子Executor的Init()函数。</p>
</blockquote>
<h3 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h3><p>我是使用TableHeapIterator获取每个tuple的，获得tuple生成需要输出tuple，后还需要判断是否满足preidcate条件。</p>
<blockquote>
<p>根据OutputSchema生成输出Tuple的过程（<strong>这里的OutputSchema可以理解成SELECT语句中选择的列</strong>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;col : output_schema-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(col.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;<span class="keyword">tuple_t</span>, &amp;table_schema));</span><br><span class="line">&#125;</span><br><span class="line">*tuple = <span class="built_in">Tuple</span>(values, output_schema);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> *catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  <span class="keyword">auto</span> table_oid = plan_-&gt;<span class="built_in">GetTableOid</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(table_oid);</span><br><span class="line">  <span class="keyword">auto</span> *table_heap = table_info_-&gt;table_.<span class="built_in">get</span>();</span><br><span class="line">  iter_ = table_heap-&gt;<span class="built_in">Begin</span>(exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">  end_ = table_heap-&gt;<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reach the end of table.</span></span><br><span class="line">  <span class="keyword">if</span> (iter_ == end_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> *predicate = plan_-&gt;<span class="built_in">GetPredicate</span>();</span><br><span class="line">  <span class="keyword">auto</span> *output_schema = <span class="built_in">GetOutputSchema</span>();</span><br><span class="line">  <span class="keyword">auto</span> table_schema = table_info_-&gt;schema_;</span><br><span class="line">  <span class="keyword">while</span> (iter_ != end_) &#123;</span><br><span class="line">    Tuple <span class="keyword">tuple_t</span> = *iter_;</span><br><span class="line">    *rid = iter_-&gt;<span class="built_in">GetRid</span>();</span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;col : output_schema-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(col.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;<span class="keyword">tuple_t</span>, &amp;table_schema));</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = <span class="built_in">Tuple</span>(values, output_schema);</span><br><span class="line">    iter_++;</span><br><span class="line">    <span class="comment">// if there is no predicate (predicate == nullptr),</span></span><br><span class="line">    <span class="comment">// or, find tuple statisfy predicate, return true.</span></span><br><span class="line">    <span class="keyword">if</span> (predicate == <span class="literal">nullptr</span> || (predicate-&gt;<span class="built_in">Evaluate</span>(tuple, output_schema)).GetAs&lt;<span class="keyword">bool</span>&gt;()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>需要判断插入数据是SQL语句给出的还是子Executor生成的，不过都需要<strong>使用TableHeap的InsertTuple方法，插入成功后需要插入索引</strong>（<strong>将tuple的key和rid插入索引，如果表有索引的话，插入、删除、更新操作都需要对索引进行操作</strong>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Init child executor first.</span></span><br><span class="line">  <span class="comment">// child executor maybe nullptr if only raw value.</span></span><br><span class="line">  <span class="keyword">if</span> (child_executor_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> *catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  table_indexes_ = catalog-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  txn_ = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (plan_-&gt;<span class="built_in">IsRawInsert</span>()) &#123;</span><br><span class="line">    iter_ = (plan_-&gt;<span class="built_in">RawValues</span>()).<span class="built_in">begin</span>();</span><br><span class="line">    end_ = (plan_-&gt;<span class="built_in">RawValues</span>()).<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertExecutor::Next</span><span class="params">([[maybe_unused]] Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (plan_-&gt;<span class="built_in">IsRawInsert</span>()) &#123;</span><br><span class="line">    <span class="comment">// Insert raw values (from SQL).</span></span><br><span class="line">    <span class="keyword">auto</span> *table_heap = (table_info_-&gt;table_).<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// use schema of table, for insert executor&#x27;s output schema is nullptr.</span></span><br><span class="line">    <span class="keyword">auto</span> schema = table_info_-&gt;schema_;</span><br><span class="line">    <span class="keyword">while</span> (iter_ != end_) &#123;</span><br><span class="line">      *tuple = <span class="built_in">Tuple</span>(*iter_, &amp;schema);</span><br><span class="line">      <span class="comment">// Insert tuple into table heap..</span></span><br><span class="line">      table_heap-&gt;<span class="built_in">InsertTuple</span>(*tuple, rid, txn_);</span><br><span class="line">      <span class="comment">// Insert tuple into indexes.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> *index_info : table_indexes_) &#123;</span><br><span class="line">        <span class="comment">// rid may be nullptr, get tuple rid from `Tuple::GetRid()`</span></span><br><span class="line">        index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(</span><br><span class="line">            tuple-&gt;<span class="built_in">KeyFromTuple</span>(schema, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid, txn_);</span><br><span class="line">      &#125;</span><br><span class="line">      iter_++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Insert tuples from nested query (child executor).</span></span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *table_heap = (table_info_-&gt;table_).<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// Insert tuple into table heap.</span></span><br><span class="line">    table_heap-&gt;<span class="built_in">InsertTuple</span>(*tuple, rid, txn_);</span><br><span class="line">    <span class="comment">// Insert tuple into table indexes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *index_info : table_indexes_) &#123;</span><br><span class="line">      <span class="comment">// rid may be nullptr, get tuple rid from `Tuple::GetRid()`</span></span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(</span><br><span class="line">          tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid,</span><br><span class="line">          txn_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>使用<code>GenerateUpdatedTuple()</code>生成更新后的Tuple，TableHeap直接更新，因为索引需要的Key的字段可能变了，所以对于索引需要先删除Entry再插入Entry。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  table_info_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  table_indexes_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  txn_ = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UpdateExecutor::Next</span><span class="params">([[maybe_unused]] Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update cannot change result set, so must return false,</span></span><br><span class="line">  <span class="comment">// and do every update in `Next()`.</span></span><br><span class="line">  Catalog *catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get tuple to update from child executor</span></span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    <span class="comment">// generate update tuple</span></span><br><span class="line">    Tuple updated_tuple = <span class="built_in">GenerateUpdatedTuple</span>(*tuple);</span><br><span class="line">    <span class="comment">// update table heap</span></span><br><span class="line">    <span class="keyword">auto</span> *table_heap = (table_info_-&gt;table_).<span class="built_in">get</span>();</span><br><span class="line">    table_heap-&gt;<span class="built_in">UpdateTuple</span>(updated_tuple, *rid, txn_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  delete index first, then insert new index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *index_info : table_indexes_) &#123;</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(</span><br><span class="line">          tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid,</span><br><span class="line">          txn_);</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(</span><br><span class="line">          updated_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),</span><br><span class="line">          *rid, txn_);</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = updated_tuple;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>TableHeap使用<code>MarkDelete()</code>标记删除对应的tuple（ApplyDelete得在Commit时进行），同时删除索引。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  table_info_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  table_indexes_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  txn_ = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteExecutor::Next</span><span class="params">([[maybe_unused]] Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  Tuple del_tuple;</span><br><span class="line">  RID del_rid;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;del_tuple, &amp;del_rid)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *table_heap = (table_info_-&gt;table_).<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// delete tuple from table heap.</span></span><br><span class="line">    table_heap-&gt;<span class="built_in">MarkDelete</span>(del_rid, txn_);</span><br><span class="line">    <span class="comment">// delete tuple from table indexes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *index_info : table_indexes_) &#123;</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(</span><br><span class="line">          del_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, *(index_info-&gt;index_-&gt;<span class="built_in">GetKeySchema</span>()),</span><br><span class="line">                                 index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),</span><br><span class="line">          del_rid, txn_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h3><p>Init()时外层循环是左孩子Executor，内层循环是右孩子Executor，左孩子Executor对于新的tuple要重新将右孩子Executor Init()，满足条件的生成join后的tuple存储起来。Next()部分就是将生成的tuple返回。</p>
<p>难点是join的predicate条件如何判断，这部分API比Sequential Scan的要复杂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((plan_-&gt;<span class="built_in">Predicate</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuple,</span><br><span class="line">                                      right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()))</span><br><span class="line">    .GetAs&lt;<span class="keyword">bool</span>&gt;()) &#123;</span><br><span class="line">    <span class="comment">// if subject to predicate, generate output tuple according to output schema.</span></span><br><span class="line">    <span class="keyword">auto</span> *output_schema = <span class="built_in">GetOutputSchema</span>();</span><br><span class="line">    std::vector&lt;Value&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;column : output_schema-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuple,</span><br><span class="line">                                                        right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    tuples_.<span class="built_in">emplace_back</span>(<span class="built_in">Tuple</span>(res, output_schema));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NestedLoopJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple left_tuple;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="comment">// double loop, generate results.</span></span><br><span class="line">  <span class="keyword">while</span> (left_executor_-&gt;<span class="built_in">Next</span>(&amp;left_tuple, &amp;left_rid)) &#123;</span><br><span class="line">    right_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    Tuple right_tuple;</span><br><span class="line">    RID right_rid;</span><br><span class="line">    <span class="keyword">while</span> (right_executor_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((plan_-&gt;<span class="built_in">Predicate</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuple,</span><br><span class="line">                                            right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()))</span><br><span class="line">              .GetAs&lt;<span class="keyword">bool</span>&gt;()) &#123;</span><br><span class="line">        <span class="comment">// if subject to predicate, generate output tuple according to output schema.</span></span><br><span class="line">        <span class="keyword">auto</span> *output_schema = <span class="built_in">GetOutputSchema</span>();</span><br><span class="line">        std::vector&lt;Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;column : output_schema-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">          res.<span class="built_in">emplace_back</span>(column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuple,</span><br><span class="line">                                                          right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        tuples_.<span class="built_in">emplace_back</span>(<span class="built_in">Tuple</span>(res, output_schema));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  iter_ = tuples_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NestedLoopJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter_ == tuples_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = *iter_;</span><br><span class="line">  iter_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p>实验假设数据是内存可以放下的，使用<code>unordered_map</code>就行，不需要使用磁盘的Hash表。</p>
<p>Init()先将左孩子的tuple插入哈希表，然后获取右孩子的tuple，满足join条件的进行join操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate hash table according to tuples from left child.</span></span><br><span class="line">  std::unordered_map&lt;<span class="keyword">hash_t</span>, std::vector&lt;Tuple&gt;&gt; mp;</span><br><span class="line">  <span class="keyword">while</span> (left_child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;</span><br><span class="line">    <span class="comment">// Get key value of tuple from left child.</span></span><br><span class="line">    Value value = plan_-&gt;<span class="built_in">LeftJoinKeyExpression</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="comment">// calculate hash value of key.</span></span><br><span class="line">    <span class="keyword">hash_t</span> hash_key = HashUtil::<span class="built_in">HashValue</span>(&amp;value);</span><br><span class="line">    <span class="comment">// insert tuple into the hash table.</span></span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(hash_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      mp[hash_key] = std::vector&lt;Tuple&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mp[hash_key].<span class="built_in">emplace_back</span>(tuple);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  right_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">auto</span> *output_schema = <span class="built_in">GetOutputSchema</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right_child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;</span><br><span class="line">    <span class="comment">// get key of tuple from right child.</span></span><br><span class="line">    Value value = plan_-&gt;<span class="built_in">RightJoinKeyExpression</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, right_child_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="comment">// calculate hash value of key.</span></span><br><span class="line">    <span class="keyword">hash_t</span> hash_key = HashUtil::<span class="built_in">HashValue</span>(&amp;value);</span><br><span class="line">    <span class="comment">// if hash key in hash table, generate output tuples.</span></span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(hash_key) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;left_tuple : mp[hash_key]) &#123;</span><br><span class="line">        std::vector&lt;Value&gt; output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : output_schema-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">          Value <span class="keyword">val_t</span> =</span><br><span class="line">              (col.<span class="built_in">GetExpr</span>())</span><br><span class="line">                  -&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;tuple, right_child_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">          output.<span class="built_in">emplace_back</span>(<span class="keyword">val_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        results_.<span class="built_in">emplace_back</span>(<span class="built_in">Tuple</span>(output, output_schema));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  iter_ = results_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter_ == results_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = *iter_;</span><br><span class="line">  iter_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>Aggregation操作，常见的有COUNT，AVG，SUM等等，很多时候会和GROUP BY一起使用，注意需要判断是否有having条件，在输出时判断（这部分要看的API挺多的。。。，虽然写的很少）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">AggregationExecutor::<span class="built_in">AggregationExecutor</span>(ExecutorContext *exec_ctx, <span class="keyword">const</span> AggregationPlanNode *plan,</span><br><span class="line">                                         std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx),</span><br><span class="line">      <span class="built_in">plan_</span>(plan),</span><br><span class="line">      <span class="built_in">child_</span>(std::<span class="built_in">move</span>(child)),</span><br><span class="line">      <span class="built_in">aht_</span>(plan_-&gt;<span class="built_in">GetAggregates</span>(), plan_-&gt;<span class="built_in">GetAggregateTypes</span>()),</span><br><span class="line">      <span class="built_in">aht_iterator_</span>(aht_.<span class="built_in">Begin</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="comment">// Initialize aggregation hash table.</span></span><br><span class="line">  <span class="comment">// aht_.GenerateInitialAggregateValue();</span></span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;</span><br><span class="line">    AggregateKey agg_key = <span class="built_in">MakeAggregateKey</span>(&amp;tuple);</span><br><span class="line">    AggregateValue agg_value = <span class="built_in">MakeAggregateValue</span>(&amp;tuple);</span><br><span class="line">    <span class="comment">// Insert key, value to aggregation hash table.</span></span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(agg_key, agg_value);</span><br><span class="line">  &#125;</span><br><span class="line">  aht_iterator_ = aht_.<span class="built_in">Begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AggregationExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (aht_iterator_ == aht_.<span class="built_in">End</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> *having = plan_-&gt;<span class="built_in">GetHaving</span>();</span><br><span class="line">  AggregateKey agg_key = aht_iterator_.<span class="built_in">Key</span>();</span><br><span class="line">  AggregateValue agg_value = aht_iterator_.<span class="built_in">Val</span>();</span><br><span class="line">  ++aht_iterator_;</span><br><span class="line">  <span class="comment">// having predicate</span></span><br><span class="line">  <span class="keyword">if</span> (having == <span class="literal">nullptr</span> || having-&gt;<span class="built_in">EvaluateAggregate</span>(agg_key.group_bys_, agg_value.aggregates_).GetAs&lt;<span class="keyword">bool</span>&gt;()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *output_schema = <span class="built_in">GetOutputSchema</span>();</span><br><span class="line">    std::vector&lt;Column&gt; cols = output_schema-&gt;<span class="built_in">GetColumns</span>();</span><br><span class="line">    std::vector&lt;Value&gt; output;</span><br><span class="line">    output.<span class="built_in">reserve</span>(cols.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;col : cols) &#123;</span><br><span class="line">      output.<span class="built_in">emplace_back</span>(col.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateAggregate</span>(agg_key.group_bys_, agg_value.aggregates_));</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = <span class="built_in">Tuple</span>(output, output_schema);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Next</span>(tuple, rid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Limit和Distinct"><a href="#Limit和Distinct" class="headerlink" title="Limit和Distinct"></a>Limit和Distinct</h3><p>过于简单，不赘述。</p>
<h2 id="Project-4-Concurrency-Control"><a href="#Project-4-Concurrency-Control" class="headerlink" title="Project 4 Concurrency Control"></a>Project 4 Concurrency Control</h2><h3 id="事务与隔离级别"><a href="#事务与隔离级别" class="headerlink" title="事务与隔离级别"></a>事务与隔离级别</h3><p>SQL语句中，事务以BEGIN开始，COMMIT或者ABORT结束，对应于TransactionManager中的<code>Begin(),Commit(),Abort()</code>，通常一个事务会由多个SQL语句组成，而数据库可以同时运行多个事务，这就涉及到事务的隔离。</p>
<p>较为常见的隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别 (低-&gt;高)</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（Unrepeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化（Serializable）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ol>
<li>“脏读 (Dirty Read)”的发生场景：事务1修改数据，被事务2读到，之后事务1 Abort，那么事务2读到的是脏数据。</li>
<li>“不可重复读（Unrepeatable Read）”的发生场景：事务1读数据，事务2修改数据，事务1再读数据，事务1两次读到的数据不一致。</li>
<li>“幻读（Phantom Read）”的发生场景：事务1进行Aggregation操作（统计行数等），事务2插入或者删除数据，两次统计不一致。</li>
</ol>
<p>Project 4 只要求实现Read Uncommitted，Read Committed，Repeatable Read。实现隔离级别主要是在Scan，Insert，Delete，Update的算子中实现：</p>
<ul>
<li>Read Uncommited：对读操作不加共享锁锁，对写操作加互斥锁，操作完成就解锁。</li>
<li>Read Committed：读操作加共享锁，读完解锁，写操作加互斥锁，直到Commit / Abort才解锁。</li>
<li>Repeatable Read：实现2PL，读操作加共享锁，写操作加互斥锁，GROWING阶段加锁，SHRINKING阶段解锁。</li>
</ul>
<h3 id="LockManager"><a href="#LockManager" class="headerlink" title="LockManager"></a>LockManager</h3><p>事务向LockManager请求加锁操作，Project 4 实现的是Tuple级别的Lock，即LockManager需要维护tuple及其LockRequest队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockManager handles transactions asking for locks on records.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockManager</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">LockMode</span> &#123;</span> SHARED, EXCLUSIVE &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockRequest</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockRequest</span>(<span class="keyword">txn_id_t</span> txn_id, LockMode lock_mode) : <span class="built_in">txn_id_</span>(txn_id), <span class="built_in">lock_mode_</span>(lock_mode), <span class="built_in">granted_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">txn_id_t</span> txn_id_;</span><br><span class="line">    LockMode lock_mode_;</span><br><span class="line">    <span class="keyword">bool</span> granted_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockRequestQueue</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    std::list&lt;LockRequest&gt; request_queue_;</span><br><span class="line">    <span class="comment">// for notifying blocked transactions on this rid</span></span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="comment">// txn_id of an upgrading transaction (if any)</span></span><br><span class="line">    <span class="keyword">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LockManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">LockManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LockShared</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LockExclusive</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LockUpgrade</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Unlock</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex latch_;</span><br><span class="line">  <span class="comment">/** Lock table for lock requests. */</span></span><br><span class="line">  std::unordered_map&lt;RID, LockRequestQueue&gt; lock_table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里并不需要自己在LockRequestQueue中增加mutex，事务先获取LockManager的latch_，找到对应的LockRequestQueue，循环判断是否满足加锁条件，如果不满足，用对应的LockRequestQueue中的条件变量<code>cv_</code>进行<code>wait()</code>，如果有一个事务解锁了，用<code>notify_all()</code>通知在对应的<code>LockRequestQueue</code>中的条件变量<code>cv_</code>等待的线程。</p>
<p>助教建议先实现<strong>不带死锁检测的加锁，解锁操作</strong>：</p>
<ol>
<li>加读锁：如果等待队列中无写锁，可以加，否则就等待。（等待队列中的请求按txn_id从小到大排，即从旧事务到新事务排）</li>
<li>加写锁：等待队列中只有当前事务（没有其他读锁、写锁）。</li>
<li>升级锁：等待队列中只有当前事务（没有其他读锁、写锁）。</li>
<li>解锁：解锁时，如果事务是<code>REPEATABLE_READ</code>隔离级别，需要将事务状态设置为<code>SHRINKING</code>。</li>
</ol>
<p>这是我一开始想的简单版本，可以通过本地LockManagerTest的前3个测试。</p>
<blockquote>
<p>我在实现时，请求共享锁、排他锁时都会将请求先放入队列，获得锁之后再将LockRequest中的<code>granted_</code>变成true。</p>
</blockquote>
<h3 id="Deadlock-Prevention-（Wound-Wait）"><a href="#Deadlock-Prevention-（Wound-Wait）" class="headerlink" title="Deadlock Prevention （Wound-Wait）"></a>Deadlock Prevention （Wound-Wait）</h3><p>Wound-Wait死锁检测的加锁、解锁操作：</p>
<ol>
<li>加读锁：遍历整个等待队列，读锁可以共存，但是遇到写锁分情况判断：<ul>
<li>请求写锁的事务更老，那么遍历完成后当前事务需要等待。</li>
<li>请求写锁的事务更年轻，那么请求写锁的年轻事务设置为ABORTED状态，并删除对应的请求以及事务的SharedLockSet中的rid。</li>
</ul>
</li>
<li>加写锁：遍历整个等待队列：<ul>
<li>如果有比当前事务更老的事务请求锁，当前事务设置为ABORTED状态，删除对应的请求以及事务的ExclusiveLockSet中的rid。</li>
<li>如果有比当前事务年轻的事务请求锁，该事务设置为ABORTED状态，删除对应的请求以及事务的SharedLockSet和ExclusiveLockSet中的rid。</li>
</ul>
</li>
<li>升级锁：遍历整个等待队列：<ul>
<li>如果有比当前事务更老的事务，遍历完成后当前事务等待。</li>
<li>如果有比当前事务年轻的事务请求锁，该事务设置为ABORTED状态，删除对应的请求以及事务的SharedLockSet和ExclusiveLockSet中的rid。</li>
</ul>
</li>
</ol>
<h4 id="LockShared"><a href="#LockShared" class="headerlink" title="LockShared()"></a><code>LockShared()</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LockManager::LockShared</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if transaction is aborted, return false.</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if isolation level is read_uncommitted, throw exception.</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::READ_UNCOMMITTED) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// abort if lock tuple on shrinking and REPEATABLE_READ.</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::REPEATABLE_READ &amp;&amp; txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// transaction already hold shared lock on tuple.</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">IsSharedLocked</span>(rid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">table_lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  LockRequestQueue &amp;lock_request_queue = lock_table_[rid];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. predicates to acquire shared lock :</span></span><br><span class="line">  <span class="comment">// no exclusive lock in lock request queue.</span></span><br><span class="line">  <span class="comment">// 2. Deadlock prevention (Wound-Wait)</span></span><br><span class="line">  <span class="comment">// holding transaction requests for shared lock, traverse request queue:</span></span><br><span class="line">  <span class="comment">// (1) for shared lock, compatible.</span></span><br><span class="line">  <span class="comment">// (2) for exclusive lock:</span></span><br><span class="line">  <span class="comment">// [2.1] if request transaction is younger, abort request transaction.</span></span><br><span class="line">  <span class="comment">// [2.2] if request transaction is older, holding transaction wait.</span></span><br><span class="line">  <span class="keyword">auto</span> wait_for_shared_lock = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iter-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">        <span class="keyword">auto</span> txn_id = iter-&gt;txn_id_;</span><br><span class="line">        <span class="keyword">if</span> (txn_id &lt; txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          res = <span class="literal">false</span>;</span><br><span class="line">          iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (txn_id &gt; txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          Transaction *trans = TransactionManager::<span class="built_in">GetTransaction</span>(txn_id);</span><br><span class="line">          trans-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          trans-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          iter = lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          trans-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert lock request in correct place, keep transaction from old to young.</span></span><br><span class="line">  <span class="comment">// add `rid` to shared lock set early, for transaction may be aborted by other transaction (at same / different rid).</span></span><br><span class="line">  <span class="built_in">InsertTxnIntoLockRequest</span>(&amp;lock_request_queue, txn-&gt;<span class="built_in">GetTransactionId</span>(), LockMode::SHARED);</span><br><span class="line">  txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">emplace</span>(rid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">wait_for_shared_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// holding transaction was aborted</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">      lock_request_queue.cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_request_queue.cv_.<span class="built_in">wait</span>(table_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  txn-&gt;<span class="built_in">SetState</span>(TransactionState::GROWING);</span><br><span class="line">  <span class="comment">// set lock request granted.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : lock_request_queue.request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      item.granted_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert transaction into lock request by order (old -&gt; young).</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LockManager::InsertTxnIntoLockRequest</span><span class="params">(LockRequestQueue *lock_request_queue, <span class="keyword">txn_id_t</span> txn_id, LockMode lock_mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lock_request_queue-&gt;request_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    lock_request_queue-&gt;request_queue_.<span class="built_in">emplace_back</span>(<span class="built_in">LockRequest</span>(txn_id, lock_mode));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> iter = lock_request_queue-&gt;request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span> (iter != lock_request_queue-&gt;request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;txn_id_ &lt; txn_id) &#123;</span><br><span class="line">      iter++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;txn_id_ == txn_id) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lock_request_queue-&gt;request_queue_.<span class="built_in">insert</span>(iter, <span class="built_in">LockRequest</span>(txn_id, lock_mode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LockExclusive"><a href="#LockExclusive" class="headerlink" title="LockExclusive()"></a><code>LockExclusive()</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LockManager::LockExclusive</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::REPEATABLE_READ &amp;&amp; txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">IsExclusiveLocked</span>(rid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">table_lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  LockRequestQueue &amp;lock_request_queue = lock_table_[rid];</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// predicate to acquire exclusive lock:</span></span><br><span class="line">  <span class="comment">// (no shared lock or exclusive lock in request queue)</span></span><br><span class="line">  <span class="comment">// (see also no request in request queue)</span></span><br><span class="line">  <span class="comment">// With Deadlock prevention:</span></span><br><span class="line">  <span class="comment">// Traverse lock request queue:</span></span><br><span class="line">  <span class="comment">// 1. If holding transaction is older than request transaction, abort request transaction.</span></span><br><span class="line">  <span class="comment">// 2. If holding transaction is younger than request transaction, abort holding transaction.</span></span><br><span class="line">  <span class="keyword">auto</span> wait_for_exclusive_lock = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> txn_id = iter-&gt;txn_id_;</span><br><span class="line">      <span class="comment">// `txn-&gt;GetTransactionId() == 9` used to pass `WoundWaitFairnessTest` in gradescope.</span></span><br><span class="line">      <span class="comment">// I print information in gradescope result, but cannot understand the logic of test.</span></span><br><span class="line">      <span class="comment">// younger transaction should be aborted.</span></span><br><span class="line">      <span class="keyword">if</span> (txn_id &gt; txn-&gt;<span class="built_in">GetTransactionId</span>() || txn-&gt;<span class="built_in">GetTransactionId</span>() == <span class="number">9</span>) &#123;</span><br><span class="line">        Transaction *trans = TransactionManager::<span class="built_in">GetTransaction</span>(txn_id);</span><br><span class="line">        trans-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">        trans-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">        trans-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">        iter = lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (txn_id &lt; txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">        <span class="comment">// exist transaction older than holding transaction, holding transaction set aborted.</span></span><br><span class="line">        txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">        res = <span class="literal">false</span>;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InsertTxnIntoLockRequest</span>(&amp;lock_request_queue, txn-&gt;<span class="built_in">GetTransactionId</span>(), LockMode::EXCLUSIVE);</span><br><span class="line">  txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">emplace</span>(rid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">wait_for_exclusive_lock</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">      lock_request_queue.cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_request_queue.cv_.<span class="built_in">wait</span>(table_lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txn-&gt;<span class="built_in">SetState</span>(TransactionState::GROWING);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : lock_request_queue.request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      item.granted_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LockUpgrade"><a href="#LockUpgrade" class="headerlink" title="LockUpgrade()"></a><code>LockUpgrade()</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LockManager::LockUpgrade</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::REPEATABLE_READ &amp;&amp; txn-&gt;<span class="built_in">GetState</span>() == TransactionState::SHRINKING) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">IsExclusiveLocked</span>(rid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">table_lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  LockRequestQueue &amp;lock_request_queue = lock_table_[rid];</span><br><span class="line">  <span class="comment">// predicates for waiting upgrade lock.</span></span><br><span class="line">  <span class="comment">// 1. no other upgrade lock.</span></span><br><span class="line">  <span class="comment">// 2. should only contain holding transaction&#x27;s lock request.</span></span><br><span class="line">  <span class="comment">// Traverse lock request queue:</span></span><br><span class="line">  <span class="comment">// 1. holding transaction is older than request transaction, abort request transaction.</span></span><br><span class="line">  <span class="comment">// 2. holding transaction is younger than request transaction, wait.</span></span><br><span class="line">  <span class="keyword">auto</span> wait_for_upgrade_lock = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other transaction request for upgrade lock, abort holding transaction.</span></span><br><span class="line">    <span class="keyword">if</span> (lock_request_queue.upgrading_ != INVALID_TXN_ID &amp;&amp; lock_request_queue.upgrading_ != txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> txn_id = iter-&gt;txn_id_;</span><br><span class="line">      <span class="keyword">if</span> (txn_id &lt; txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">        res = <span class="literal">false</span>;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (txn_id == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (txn_id &gt; txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">        Transaction *trans = TransactionManager::<span class="built_in">GetTransaction</span>(txn_id);</span><br><span class="line">        trans-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">        trans-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">        iter = lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">        trans-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other transaction request for upgrade lock, abort holding transaction.</span></span><br><span class="line">  <span class="keyword">if</span> (lock_request_queue.upgrading_ != INVALID_TXN_ID &amp;&amp; lock_request_queue.upgrading_ != txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lock_request_queue.upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">wait_for_upgrade_lock</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="comment">// erase lock request of current transaction on `rid`.</span></span><br><span class="line">      <span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">while</span> (iter != lock_request_queue.request_queue_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">          lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">      &#125;</span><br><span class="line">      lock_request_queue.cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_request_queue.cv_.<span class="built_in">wait</span>(table_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : lock_request_queue.request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      item.lock_mode_ = LockMode::EXCLUSIVE;</span><br><span class="line">      item.granted_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">  txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">emplace</span>(rid);</span><br><span class="line">  lock_request_queue.upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock()"></a><code>Unlock()</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LockManager::Unlock</span><span class="params">(Transaction *txn, <span class="keyword">const</span> RID &amp;rid)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// transaction doesn&#x27;t hold lock on rid, return false.</span></span><br><span class="line">  <span class="keyword">if</span> (!txn-&gt;<span class="built_in">IsSharedLocked</span>(rid) &amp;&amp; !txn-&gt;<span class="built_in">IsExclusiveLocked</span>(rid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// transaction is in GROWING state and isolation level is REPEATZABLE_READ, </span></span><br><span class="line">  <span class="comment">// set transaction to SHRINKING state.</span></span><br><span class="line">  <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetIsolationLevel</span>() == IsolationLevel::REPEATABLE_READ &amp;&amp; txn-&gt;<span class="built_in">GetState</span>() == TransactionState::GROWING) &#123;</span><br><span class="line">    txn-&gt;<span class="built_in">SetState</span>(TransactionState::SHRINKING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">table_lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  LockRequestQueue &amp;lock_request_queue = lock_table_[rid];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lock_request_queue.request_queue_.<span class="built_in">begin</span>(); iter != lock_request_queue.request_queue_.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      iter = lock_request_queue.request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">      txn-&gt;<span class="built_in">GetSharedLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">      txn-&gt;<span class="built_in">GetExclusiveLockSet</span>()-&gt;<span class="built_in">erase</span>(rid);</span><br><span class="line">      lock_request_queue.cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h3><p>在在executor中该加锁的地方加锁，该解锁的地方解锁（scan时加写锁，update时加升级锁/写锁，其实delete和insert操作会导致幻读，需要Serializable隔离级别，因此实际也没这部分的幻读测试，但实验要求实现）。</p>
<blockquote>
<p>至此，对于常见的SQL语句，在使用2PL的情况下，我能够理解语句的执行过程，事务加锁解锁的过程等。</p>
</blockquote>
<h3 id="unique-lock与conditional-variable多线程编程的方式与理解"><a href="#unique-lock与conditional-variable多线程编程的方式与理解" class="headerlink" title="unique_lock与conditional_variable多线程编程的方式与理解"></a><code>unique_lock</code>与<code>conditional_variable</code>多线程编程的方式与理解</h3><p>unique_lock获取互斥量mutex，在获取到mutex后，线程才会继续下面的操作，unique_lock和scope_lock，lock_guard一样是RAII的，在超出作用域后会自动析构，如果unique_lock持有互斥量的话在析构时会释放。</p>
<blockquote>
<p>线程调度一般是交给OS决定的，OS调度到一个线程运行，如果unique_lock失败就会继续等待。</p>
</blockquote>
<p>unique_lock与conditional_variable经常一起使用，因为conditional_variable可以通知阻塞在该条件变量上的线程，这是多线程的一个常见范式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::mutex latch;</span><br><span class="line">std::conditional_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">Predicates</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Actions</span>();</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br></pre></td></tr></table></figure>

<p>如果Predicates()只会访问线程自己的变量以及mutex能够管理的资源，那么这段代码就能保证多线程的准确性：</p>
<ol>
<li>首先，只有在获得latch后，才会执行Predicates()，不会有其它线程影响。</li>
<li>如果不满足条件，unique_lock在条件变量上等待，直到有人调用该条件变量的<code>notify_all()</code>或者<code>notify_one()</code>（notify_one是随机选一个在该条件变量上等待的线程唤醒）</li>
</ol>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/02/19/MIT6-S081-Lab1/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MIT6.S081 Lab1 Unix utilities</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/01/24/hello-world/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Hello World</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">wzmw-zr</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
</div>



</body>
</html>
